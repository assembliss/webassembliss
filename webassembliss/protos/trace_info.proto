syntax = "proto3";

// This file can be compiled with: protoc trace_info.proto --python_out=py --js_out=js
// That will generate the trace_info.py file that we can import in the python backend, and a trace_info.js that we can import in the frontend.

// PS: You may need to download protoc-gen-js from github: https://github.com/protocolbuffers/protobuf-javascript/releases/
// Then, assuming you have unzipped the appropriate file inside ./js/plugin, you can run:
// protoc trace_info.proto --python_out=py --js_out=js --plugin=protoc-gen-js=./js/plugin/bin/protoc-gen-js

// Message to hold information about a single instruction execution.
// It stores the differences in registers/memory/flags/output this instruction caused.
message TraceStep {
  string line_executed = 1;
  string stdout = 2;
  string stderr = 3;
  optional sint32 exit_code = 4;
  map<string, sint64> register_delta = 5;
  map<string, bool> flag_delta = 6;
  map<uint64, fixed64> memory_delta = 7;
}

// Message to hold information about an entire emulation.
// It stores information about the architecture emulated and a list of TraceSteps.
message ExecutionTrace {
  string rootfs = 1;
  bool assembled_ok = 2;
  bool linked_ok = 3;
  string argv = 4;
  optional sint32 exit_code = 5;
  bool reached_max_steps = 6;
  // One entry for each separate memory area that is mapped for the user program;
  // Entries follow this format: start_address -> end_address
  map<uint64, uint64> mapped_memory = 7;
  repeated TraceStep steps = 8;
}
