syntax = "proto3";

// This file can be compiled with: protoc trace_info.proto --python_out=py --js_out=../static/js/protos --plugin=protoc-gen-js=./js/plugin/bin/protoc-gen-js
// That will generate the trace_info_pb2.py file that we can import in the python backend, and appropriate .js files we can import in the frontend.

// PS: You may need to download protoc-gen-js from github: https://github.com/protocolbuffers/protobuf-javascript/releases/
// Then, assuming you have unzipped the appropriate file inside ./js/plugin, you can try running the command again:
// protoc trace_info.proto --python_out=py --js_out=../static/js/protos --plugin=protoc-gen-js=./js/plugin/bin/protoc-gen-js
// TODO: add protoc-gen-js plugin installation into the Dockerfile.

// Message to hold information about the line that was executed;
// It stores an index for the filename inside of ExecutionTrace.source_filenames, and the line number.
message LineInfo {
  int32 filename_index = 1;
  int32 linenum = 2;
}

// Message to hold information about a single instruction execution.
// It stores the differences in registers/memory/flags/output this instruction caused.
message TraceStep {
  LineInfo line_executed = 1;
  string stdout = 2;
  string stderr = 3;
  optional sint32 exit_code = 4;
  map<string, uint64> register_delta = 5;
  map<string, bool> flag_delta = 6;
  map<uint64, fixed64> memory_delta = 7;
}

// Message to hold information about an entire emulation.
// It stores information about the architecture emulated and a list of TraceSteps.
message ExecutionTrace {
  string rootfs = 1;
  repeated string source_filenames = 2;
  bool assembled_ok = 3;
  bool linked_ok = 4;
  string argv = 5;
  optional sint32 exit_code = 6;
  bool reached_max_steps = 7;
  // One entry for each separate memory area that is mapped for the user program;
  // Entries follow this format: start_address -> end_address
  map<uint64, uint64> mapped_memory = 8;
  repeated TraceStep steps = 9;
}
